import streamlit as st
import openpyxl
import pandas as pd
from openpyxl.utils import get_column_letter
from openpyxl.styles import PatternFill, Font, Alignment, Border, Side
import io

# Function to check if a cell has light blue background (adjust RGB if needed)
def is_light_blue(cell):
    try:
        return cell.fill.fgColor.rgb == 'FFD3D3D3'
    except:
        return False

# Function to get merged range for a cell
def get_merged_range(sheet, cell):
    for merged_range in sheet.merged_cells.ranges:
        if cell.coordinate in merged_range:
            return merged_range
    return None

# Function to make header names unique by appending suffix if duplicates
def make_unique(headers_list):
    seen = {}
    unique_headers = []
    for header in headers_list:
        if header in seen:
            seen[header] += 1
            unique_headers.append(f"{header}_{seen[header]}")
        else:
            seen[header] = 0
            unique_headers.append(header)
    return unique_headers

# Function to check if a value is truly blank (None, empty string, or whitespace only)
def is_blank_value(value):
    if value is None:
        return True
    if isinstance(value, str) and value.strip() == "":
        return True
    return False

# Function to count leading spaces in a string
def count_leading_spaces(text):
    if not isinstance(text, str):
        return 0
    return len(text) - len(text.lstrip(' '))

# Function to check if rest of row has values (excluding "Restated")
def has_row_values(sheet, row, max_col):
    for col in range(2, max_col + 1):  # Start from B (column 2)
        col_letter = get_column_letter(col)
        cell_value = sheet[f'{col_letter}{row}'].value
        # Skip truly blank
        if is_blank_value(cell_value):
            continue
        # Skip "Restated"
        if isinstance(cell_value, str) and cell_value.strip().lower() == "restated":
            continue
        # Found a real value (including zero)
        return True
    return False

# Function to check if column D has "Restated"
def has_restated_in_d(sheet, row):
    cell_d = sheet[f'D{row}']
    if cell_d.value and isinstance(cell_d.value, str):
        return cell_d.value.strip().lower() == "restated"
    return False

# Function to check if a row is hidden
def is_row_hidden(sheet, row):
    try:
        return sheet.row_dimensions[row].hidden
    except:
        return False

# Function to check if a column is completely blank
def is_column_blank(sheet, col):
    col_letter = get_column_letter(col)
    for row in range(4, sheet.max_row + 1):  # Check from row 4 onwards
        if is_row_hidden(sheet, row):
            continue
        cell_value = sheet[f'{col_letter}{row}'].value
        if not is_blank_value(cell_value):
            return False
    return True

# Function to check if a row should be ignored (Forecast-related or duplicate headers)
def should_ignore_row(cell_a_value, header_texts):
    if not cell_a_value:
        return False
    text = str(cell_a_value).strip().lower()
    
    # Ignore rows starting with "forecast"
    if text.startswith("forecast"):
        return True
    
    # Ignore rows that match header texts (duplicate headers in data)
    if text in [h.lower() for h in header_texts if h]:
        return True
    
    return False

# Function to format Excel output with styling
def format_excel_output(df, company_info):
    # Create a new workbook
    output = io.BytesIO()
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Flattened Data"
    
    # Add company info in A1
    ws['A1'] = company_info
    ws['A1'].alignment = Alignment(wrap_text=True, vertical='top', horizontal='left')
    
    # Define styles
    dark_blue_fill = PatternFill(start_color="00003366", end_color="00003366", fill_type="solid")
    white_font = Font(color="FFFFFF", bold=True)
    wrap_alignment = Alignment(wrap_text=True, vertical='center', horizontal='center')
    thin_border = Border(
        left=Side(style='thin'),
        right=Side(style='thin'),
        top=Side(style='thin'),
        bottom=Side(style='thin')
    )
    
    # Write column headers (starting from row 2)
    for col_idx, col_name in enumerate(df.columns, start=1):
        cell = ws.cell(row=2, column=col_idx, value=col_name)
        cell.fill = dark_blue_fill
        cell.font = white_font
        cell.alignment = wrap_alignment
        cell.border = thin_border
    
    # Write data rows (starting from row 3)
    for row_idx, (index_val, row_data) in enumerate(df.iterrows(), start=3):
        # Write row header (vertical heading)
        cell = ws.cell(row=row_idx, column=1, value=index_val)
        cell.fill = dark_blue_fill
        cell.font = white_font
        cell.alignment = wrap_alignment
        cell.border = thin_border
        
        # Write data values
        for col_idx, value in enumerate(row_data, start=2):
            cell = ws.cell(row=row_idx, column=col_idx, value=value)
            cell.alignment = wrap_alignment
            cell.border = thin_border
    
    # Apply table style (medium9 is similar to Table Grid)
    max_row = 2 + len(df)
    max_col = len(df.columns)
    
    # Adjust column widths
    for col_idx in range(1, max_col + 1):
        ws.column_dimensions[get_column_letter(col_idx)].width = 15
    
    # Save workbook
    wb.save(output)
    output.seek(0)
    return output

# Function to process the sheet and flatten it dynamically
def process_sheet(sheet):
    headers = [None] * sheet.max_column  # List for headers in column order (0-indexed)
    vertical_headings = []
    data_rows = []  # To store data for each vertical heading
    
    # Step 1: Process A1-A3 (combine and wrap text) - Keep as is
    a1_text = sheet['A1'].value or ""
    a2_text = sheet['A2'].value or ""
    a3_text = sheet['A3'].value or ""
    combined_a1 = f"{a1_text}\n{a2_text}\n{a3_text}".strip()
    headers[0] = combined_a1  # Column A is index 0
    
    # Dynamic Header Construction: Scan for merged cells and build hierarchies
    processed_cols = set()  # To avoid reprocessing merged columns
    header_texts = []  # Store header texts for duplicate detection
    
    for row in range(1, 4):  # Check rows 1-3 for headers
        for col in range(1, sheet.max_column + 1):
            col_letter = get_column_letter(col)
            cell = sheet[f'{col_letter}{row}']
            if col in processed_cols or cell.value in [None, 'Comments']:
                continue
            merged_range = get_merged_range(sheet, cell)
            if merged_range:
                # Parent header
                parent = cell.value or ""
                header_texts.append(str(parent).strip())
                # Get child cells (next row in the merged columns)
                child_row = row + 1
                child_values = []
                for merged_col in range(merged_range.min_col, merged_range.max_col + 1):
                    merged_col_letter = get_column_letter(merged_col)
                    child_cell = sheet[f'{merged_col_letter}{child_row}']
                    if child_cell.value:
                        child_values.append(child_cell.value)
                        header_texts.append(str(child_cell.value).strip())
                    processed_cols.add(merged_col)
                
                # Build headers for each column in the merge
                for i, merged_col in enumerate(range(merged_range.min_col, merged_range.max_col + 1)):
                    if i < len(child_values):
                        headers[merged_col - 1] = f"{parent}_{child_values[i]}"  # 0-indexed
                    else:
                        headers[merged_col - 1] = parent  # Fallback if no child
            else:
                # Single cell header (if not merged)
                if cell.value and cell.value not in ['Comments']:
                    headers[col - 1] = cell.value  # 0-indexed
                    header_texts.append(str(cell.value).strip())
    
    # Make headers unique
    headers = make_unique(headers)
    
    # Identify and mark blank columns for removal
    blank_columns = set()
    for col in range(1, sheet.max_column + 1):
        if is_column_blank(sheet, col):
            blank_columns.add(col - 1)  # Store 0-indexed
    
    # Now process rows dynamically for vertical headings and data
    current_parent = None
    current_child = None
    
    for row in range(4, sheet.max_row + 1):
        # Skip hidden rows
        if is_row_hidden(sheet, row):
            continue
            
        cell_a = sheet[f'A{row}']
        cell_a_value = cell_a.value
        
        # Skip forecast-related rows and duplicate headers
        if should_ignore_row(cell_a_value, header_texts):
            continue
        
        if not cell_a_value:
            continue
            
        # Count leading spaces to determine hierarchy
        cell_a_text = str(cell_a_value)
        leading_spaces = count_leading_spaces(cell_a_text)
        stripped_text = cell_a_text.strip()
        
        # Check if rest of row has values
        has_values = has_row_values(sheet, row, sheet.max_column)
        
        # Check for parent row:
        # 1. Light blue OR
        # 2. 0 spaces AND no values in rest of row OR
        # 3. 0 spaces AND "Restated" in column D
        is_parent = (
            is_light_blue(cell_a) or 
            (leading_spaces == 0 and not has_values) or 
            (leading_spaces == 0 and has_restated_in_d(sheet, row))
        )
        
        if is_parent:
            # This is a parent row
            current_parent = stripped_text
            current_child = None  # Reset child for new parent
            vertical_headings.append(current_parent)
            row_data = {}
            for col in range(len(headers)):
                if col not in blank_columns and headers[col]:  # Skip blank columns
                    row_data[col] = sheet[f'{get_column_letter(col+1)}{row}'].value
            data_rows.append(row_data)
        elif leading_spaces == 0 and has_values:
            # Child (0 spaces with values in rest of row)
            current_child = stripped_text
            heading = f"{current_parent}_{current_child}"
            vertical_headings.append(heading)
            row_data = {}
            for col in range(len(headers)):
                if col not in blank_columns and headers[col]:  # Skip blank columns
                    row_data[col] = sheet[f'{get_column_letter(col+1)}{row}'].value
            data_rows.append(row_data)
        elif leading_spaces >= 2 and has_values and current_child:
            # Grandchild (2+ spaces with values in rest of row)
            heading = f"{current_parent}_{current_child}_{stripped_text}"
            vertical_headings.append(heading)
            row_data = {}
            for col in range(len(headers)):
                if col not in blank_columns and headers[col]:  # Skip blank columns
                    row_data[col] = sheet[f'{get_column_letter(col+1)}{row}'].value
            data_rows.append(row_data)
        else:
            # Default: treat as child if we have a parent
            if current_parent:
                current_child = stripped_text
                heading = f"{current_parent}_{current_child}"
                vertical_headings.append(heading)
                row_data = {}
                for col in range(len(headers)):
                    if col not in blank_columns and headers[col]:  # Skip blank columns
                        row_data[col] = sheet[f'{get_column_letter(col+1)}{row}'].value
                data_rows.append(row_data)
    
    # Create DataFrame, filtering out blank columns
    if data_rows and vertical_headings:
        df = pd.DataFrame(data_rows, index=vertical_headings[:len(data_rows)])
        # Filter headers to remove blank columns
        filtered_headers = [headers[col] for col in range(len(headers)) if col not in blank_columns and headers[col]]
        df.columns = filtered_headers[:len(df.columns)]
    else:
        df = pd.DataFrame()  # Empty if no data
    
    return df, combined_a1

# Streamlit App
st.title("Excel Flattener App")
st.write("Upload an Excel file, select a tab, and download the flattened data.")

uploaded_file = st.file_uploader("Choose an Excel file", type=["xlsx"])

if uploaded_file is not None:
    try:
        # Load workbook with data_only=True to get computed values, not formulas
        wb = openpyxl.load_workbook(uploaded_file, data_only=True)
        sheet_names = wb.sheetnames
        selected_sheet = st.selectbox("Select a tab", sheet_names)
        
        if st.button("Process and Flatten"):
            sheet = wb[selected_sheet]
            flattened_df, company_info = process_sheet(sheet)
            
            st.write("Flattened Data Preview:")
            st.dataframe(flattened_df)
            
            # Format and prepare Excel for download
            formatted_excel = format_excel_output(flattened_df, company_info)
            
            st.download_button(
                label="Download Formatted Excel",
                data=formatted_excel,
                file_name=f"{selected_sheet}_flattened_formatted.xlsx",
                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            )
    except Exception as e:
        st.error(f"Error processing file: {str(e)}")
