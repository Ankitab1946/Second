import streamlit as st
import openpyxl
import pandas as pd
from openpyxl.utils import get_column_letter
import io

# Function to check if a cell has light blue background (adjust RGB if needed)
def is_light_blue(cell):
    try:
        return cell.fill.fgColor.rgb == 'FFD3D3D3'
    except:
        return False

# Function to get merged range for a cell
def get_merged_range(sheet, cell):
    for merged_range in sheet.merged_cells.ranges:
        if cell.coordinate in merged_range:
            return merged_range
    return None

# Function to make header names unique by appending suffix if duplicates
def make_unique(headers_list):
    seen = {}
    unique_headers = []
    for header in headers_list:
        if header in seen:
            seen[header] += 1
            unique_headers.append(f"{header}_{seen[header]}")
        else:
            seen[header] = 0
            unique_headers.append(header)
    return unique_headers

# Function to check if a value is truly blank (None, empty string, or whitespace only)
def is_blank_value(value):
    if value is None:
        return True
    if isinstance(value, str) and value.strip() == "":
        return True
    return False

# Function to count leading spaces in a string
def count_leading_spaces(text):
    if not isinstance(text, str):
        return 0
    return len(text) - len(text.lstrip(' '))

# Function to check if a row is a parent (A has value, rest blank - treating "Restated" as blank, but NOT zero)
def is_parent_row_by_blanks(sheet, row, max_col):
    cell_a = sheet[f'A{row}']
    if not cell_a.value:
        return False
    cell_a_text = str(cell_a.value).strip()
    if not cell_a_text:
        return False
    
    # Check if all other columns are blank (treating "Restated" as blank, but NOT zero)
    for col in range(2, max_col + 1):  # Start from B (column 2)
        col_letter = get_column_letter(col)
        cell_value = sheet[f'{col_letter}{row}'].value
        # Skip if truly blank
        if is_blank_value(cell_value):
            continue
        # Treat "Restated" as blank
        if isinstance(cell_value, str) and cell_value.strip().lower() == "restated":
            continue
        # If we get here, cell has a real value (including zero) - not a parent row
        return False
    return True

# Function to check if a row is hidden
def is_row_hidden(sheet, row):
    try:
        return sheet.row_dimensions[row].hidden
    except:
        return False

# Function to check if a column is completely blank
def is_column_blank(sheet, col):
    col_letter = get_column_letter(col)
    for row in range(4, sheet.max_row + 1):  # Check from row 4 onwards
        if is_row_hidden(sheet, row):
            continue
        cell_value = sheet[f'{col_letter}{row}'].value
        if not is_blank_value(cell_value):
            return False
    return True

# Function to check if a row should be ignored (Forecast-related or duplicate headers)
def should_ignore_row(cell_a_value, header_texts):
    if not cell_a_value:
        return False
    text = str(cell_a_value).strip().lower()
    
    # Ignore rows starting with "forecast"
    if text.startswith("forecast"):
        return True
    
    # Ignore rows that match header texts (duplicate headers in data)
    if text in [h.lower() for h in header_texts if h]:
        return True
    
    return False

# Function to process the sheet and flatten it dynamically
def process_sheet(sheet):
    headers = [None] * sheet.max_column  # List for headers in column order (0-indexed)
    vertical_headings = []
    data_rows = []  # To store data for each vertical heading
    
    # Step 1: Process A1-A3 (combine and wrap text) - Keep as is
    a1_text = sheet['A1'].value or ""
    a2_text = sheet['A2'].value or ""
    a3_text = sheet['A3'].value or ""
    combined_a1 = f"{a1_text} {a2_text} {a3_text}".strip()
    headers[0] = combined_a1  # Column A is index 0
    
    # Dynamic Header Construction: Scan for merged cells and build hierarchies
    processed_cols = set()  # To avoid reprocessing merged columns
    header_texts = []  # Store header texts for duplicate detection
    
    for row in range(1, 4):  # Check rows 1-3 for headers
        for col in range(1, sheet.max_column + 1):
            col_letter = get_column_letter(col)
            cell = sheet[f'{col_letter}{row}']
            if col in processed_cols or cell.value in [None, 'Comments']:
                continue
            merged_range = get_merged_range(sheet, cell)
            if merged_range:
                # Parent header
                parent = cell.value or ""
                header_texts.append(str(parent).strip())
                # Get child cells (next row in the merged columns)
                child_row = row + 1
                child_values = []
                for merged_col in range(merged_range.min_col, merged_range.max_col + 1):
                    merged_col_letter = get_column_letter(merged_col)
                    child_cell = sheet[f'{merged_col_letter}{child_row}']
                    if child_cell.value:
                        child_values.append(child_cell.value)
                        header_texts.append(str(child_cell.value).strip())
                    processed_cols.add(merged_col)
                
                # Build headers for each column in the merge
                for i, merged_col in enumerate(range(merged_range.min_col, merged_range.max_col + 1)):
                    if i < len(child_values):
                        headers[merged_col - 1] = f"{parent}_{child_values[i]}"  # 0-indexed
                    else:
                        headers[merged_col - 1] = parent  # Fallback if no child
            else:
                # Single cell header (if not merged)
                if cell.value and cell.value not in ['Comments']:
                    headers[col - 1] = cell.value  # 0-indexed
                    header_texts.append(str(cell.value).strip())
    
    # Make headers unique
    headers = make_unique(headers)
    
    # Identify and mark blank columns for removal
    blank_columns = set()
    for col in range(1, sheet.max_column + 1):
        if is_column_blank(sheet, col):
            blank_columns.add(col - 1)  # Store 0-indexed
    
    # Stack-based hierarchy tracking
    # Stack will store (indent_level, text) tuples
    hierarchy_stack = []
    
    for row in range(4, sheet.max_row + 1):
        # Skip hidden rows
        if is_row_hidden(sheet, row):
            continue
            
        cell_a = sheet[f'A{row}']
        cell_a_value = cell_a.value
        
        # Skip forecast-related rows and duplicate headers
        if should_ignore_row(cell_a_value, header_texts):
            continue
        
        if not cell_a_value:
            continue
            
        # Count leading spaces to determine hierarchy
        cell_a_text = str(cell_a_value)
        leading_spaces = count_leading_spaces(cell_a_text)
        stripped_text = cell_a_text.strip()
        
        # Check if this is a parent row (light blue OR A populated with rest blank)
        is_parent = is_light_blue(cell_a) or is_parent_row_by_blanks(sheet, row, sheet.max_column)
        
        if is_parent and leading_spaces == 0:
            # This is a top-level parent row - reset hierarchy
            hierarchy_stack = [(0, stripped_text)]
            heading = stripped_text
        else:
            # Pop stack until we find the appropriate parent level
            while hierarchy_stack and hierarchy_stack[-1][0] >= leading_spaces:
                hierarchy_stack.pop()
            
            # Build heading from stack
            if hierarchy_stack:
                parent_parts = [item[1] for item in hierarchy_stack]
                heading = "_".join(parent_parts + [stripped_text])
            else:
                heading = stripped_text
            
            # Add current item to stack
            hierarchy_stack.append((leading_spaces, stripped_text))
        
        vertical_headings.append(heading)
        row_data = {}
        for col in range(len(headers)):
            if col not in blank_columns and headers[col]:  # Skip blank columns
                row_data[col] = sheet[f'{get_column_letter(col+1)}{row}'].value
        data_rows.append(row_data)
    
    # Create DataFrame, filtering out blank columns
    if data_rows and vertical_headings:
        df = pd.DataFrame(data_rows, index=vertical_headings[:len(data_rows)])
        # Filter headers to remove blank columns
        filtered_headers = [headers[col] for col in range(len(headers)) if col not in blank_columns and headers[col]]
        df.columns = filtered_headers[:len(df.columns)]
    else:
        df = pd.DataFrame()  # Empty if no data
    return df

# Streamlit App
st.title("Excel Flattener App")
st.write("Upload an Excel file, select a tab, and download the flattened data.")

uploaded_file = st.file_uploader("Choose an Excel file", type=["xlsx"])

if uploaded_file is not None:
    try:
        # Load workbook with data_only=True to get computed values, not formulas
        wb = openpyxl.load_workbook(uploaded_file, data_only=True)
        sheet_names = wb.sheetnames
        selected_sheet = st.selectbox("Select a tab", sheet_names)
        
        if st.button("Process and Flatten"):
            sheet = wb[selected_sheet]
            flattened_df = process_sheet(sheet)
            
            st.write("Flattened Data Preview:")
            st.dataframe(flattened_df)
            
            # Prepare CSV for download
            csv_buffer = io.StringIO()
            flattened_df.to_csv(csv_buffer)
            csv_data = csv_buffer.getvalue()
            
            st.download_button(
                label="Download Flattened Data as CSV",
                data=csv_data,
                file_name=f"{selected_sheet}_flattened.csv",
                mime="text/csv"
            )
    except Exception as e:
        st.error(f"Error processing file: {str(e)}")
